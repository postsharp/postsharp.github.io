---
layout: post 
comments: true
title: "What really changed between 1.0 and 1.5 #2: Understanding reflection wrappers"
date: 2008-10-28 22:43:42 +01:00
categories: [General]
permalink: /post/what-really-changed-between-1-0-and-1-5-2-understanding-reflection-wrappers.html
author: "Gael Fraiteur"
---
<p>In the <a href="http://www.postsharp.org/blog/2008/10/what-really-changed-between-10-and-15-1-targeting-silverlight-and-the-compact-framework/">first part</a> of this article, I explained that Silverlight (SL) or Compact Framework (CF) assemblies were not loaded in the CLR. However, as you could have noticed in the last sample, user code still receives instances of <strong>Type</strong>, <strong>FieldInfo</strong>, or <strong>MethodBase</strong>. How is this possible, since assemblies are not loaded, even not "for reflection only"?</p>


 <p>Well, here, there is some magic. All these classes (<strong>Type</strong>, <strong>FieldInfo</strong>, or <strong>MethodBase</strong>) are actually abstract ones. You are used to runtime implementations (<strong>RuntimeType</strong>, <strong>RuntimeFieldInfo</strong> and so on). But in PostSharp, you don't get runtime implementations (fairly enough, since we are at build time!), so you get so-called <em>reflection wrappers</em>.</p> <p><strong>Reflection wrappers are an emulation of System.Reflection that purely relies on the PostSharp object model</strong>.</p> <p>Once again to be sure: Reflection wrappers look like System.Reflection but it is not System.Reflection.</p> <p>And now something even more important:</p> <p><strong>Even if you target the full framework, you receive reflection wrappers instead of runtime objects</strong>.</p> <p>And this is another big difference between 1.0 and 1.5: 1.0 was not very strict about this; sometimes you received reflection wrappers and sometimes (notoriously in <strong>CompoundAspect</strong>) runtime objects. In version 1.5, you always receive reflection wrappers.</p> <h3>Gotchaes that will get you</h3> <p>There are subtle differences between PostSharp reflection wrappers and native System.Reflection. If you don't understand them, you risk spending hours in debugging.</p> <ul> <li><strong>Never compare by reference</strong>. That is, never use the equal (==) operator. Unlike native System.Reflection, two instances can represent the same thing. What is more, comparing a wrapper to a native element of System.Reflection never works. So use the <strong>Equals</strong> method instead of the == operator.  </li><li><strong>Never uses native equality or inheritance comparing methods</strong>. So don't use <strong>typeof(Guid).Equals(targetType)</strong> but <strong>targetType.Equals(typeof(Guid))</strong>. I know this sucks (equality is supposed to be commutative), but... there is no workaround!</li></ul> <p>The safest way is to use the class <strong>PostSharp.Reflection.ReflectionTypeComparer</strong> for all comparisons... or when you build a dictionary.</p> <h3>Getting the underlying runtime object</h3> <p>That being said, unless you target SL or CF, you can always retrieve the "usual" runtime/native object and work, well, as usually.</p> <p>First, let me give you a good reason <em>not</em> to do it: doing so would load the type in the CLR, which would have some performance penalty, and may sometimes not succeed at all (for instance if you have an unresolved <strong>extern</strong> method -- unresolved because you want to implement them using PostSharp, for instance). It seems that static constructors are not invoked just because of loading the <strong>Type</strong> object, and I hope (but am not sure) that methods are not JIT compiled. So the reason is maybe good but arguably small, I have to admit.</p> <p>So if you don't care about the eventual performance penalty, go for it: the secret is to retrieve the property <strong>Type.UnderlyingSystemType</strong>, <strong>FieldInfo.UnderlyingSystemField</strong> or <strong>MethodBase.UnderlyingSystemMethod</strong>. You will get a real-native-runtime-system object.</p> <p>Since even PostSharp 1.5 loads assemblies in the CLR (when not targeting SL or CF), the difference is maybe slight. But future versions of PostSharp may avoid loading assemblies in the CLR unless strictly necessary. And by requiring the underlying runtime element, you make it necessary... maybe unnecessarily.</p> <h3>Getting the assembly</h3> <p>A problem with reflection wrappers is that <strong>Assembly </strong>is a sealed class; we cannot override it. So you cannot get a transparent assembly wrapper. So instead of getting an <strong>Assembly </strong>(typically in a <strong>CompoundAspect</strong> applied at assembly level), you will get an <strong>IAssemblyWrapper</strong>. And, yes, you can use <strong>IAssemblyWrapper.UnderlyingSystemAssembly</strong> if you like.</p> <h3>Conclusion</h3> <p>Pay attention: reflection wrappers are not 'usual' System.Reflection objects! </p>
