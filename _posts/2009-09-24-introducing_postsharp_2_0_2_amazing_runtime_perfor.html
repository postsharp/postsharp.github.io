---
layout: post 
comments: true
title: "Introducing PostSharp 2.0: #2 - Amazing Runtime Performance Enhancements"
date: 2009-09-24 15:22:46 +02:00
categories: [General]
permalink: /post/introducing-postsharp-2-0-2-amazing-runtime-performance-enhancements.html
author: "Gael Fraiteur"
---
<p>In my
<a href="http://www.postsharp.org/blog/introducing-postsharp-20-1-notifypropertychanged">
previous post</a>, I have given a quick overview of some new features of the 
aspect weaver.</p>
<p><b>Equally important to features: runtime performance.</b></p>
<p>PostSharp 1.5 already did a great job compared to other aspect frameworks. 
However, this could still be greatly improved. And this had been done in 
PostSharp 2.0.</p>
<p>Take, for instance, a rather simple aspect: a performance counter. Say we 
want to increase a counter every time a method is executed. The easiest and most 
efficient way with PostSharp 1.5 is to create an aspect of type <i>
OnMethodBoundaryAspect</i> and to implement the <i>OnEntry</i>:</p>
<pre>[Serializable]
public sealed class MethodInvocationCounterAttribute : OnMethodBoundaryAspect
{
    [NonSerialized]
    private PerformanceCounter performanceCounter;

    public MethodInvocationCounterAttribute(string category, string name)
    {
        this.Category = category;
        this.Name = name;
    }

    public string Category { get; private set; }
    public string Name { get; private set; }

    public override void RuntimeInitialize(System.Reflection.MethodBase method)
    {
        this.performanceCounter = new PerformanceCounter(this.Category, 
                                                         this.Name, false);
    }

    public override void OnEntry(MethodExecutionEventArgs eventArgs)
    {
        this.performanceCounter.Increment();
    }

}</pre>
<p>Now let&#39;s apply this aspect on an empty method (and forbid inlining), and put 
it on the test bench (here on my AMD Phenom II X4 940 3.00 GHz):</p>
<table>
<tr>
<th>Implementation</th>
<th>CPU Time (ns)</th>
<th>Overhead (ns)</th>
</tr>
<tr>
<td>Manual implementation</td>
<td>26</td>
<td>0</td>
</tr>
<tr>
<td>PostSharp 1.5</td>
<td>108</td>
<td>82</td>
</tr>
</table>

<p>As you can see, in PostSharp 1.5, the overhead of the using an aspect, 
compared to hand coding, is 108 - 26 = 82 ns (remember, a nanosecond is a
<i>billionth</i> of a second). What&#39;s the problem? The aspect overhead may is 
more than 3 
times the aspect effect itself! If the aspect has to be invoked thousands of 
times per second, its cost can surely not be ignored.</p>
<p>Now look at the benchmark with PostSharp 2.0:</p>
<table>
<tr>
<th>Implementation</th>
<th>CPU Time (ns)</th>
<th>Overhead (ns)</th>
</tr>
<tr>
<td>Manual implementation</td>
<td>26</td>
<td>0</td>
</tr>
<tr>
<td>PostSharp 2.0</td>
<td>29</td>
<td>3</td>
</tr>
</table>

<p>This time, it&#39;s much better. <b>For this specific aspect, PostSharp 2.0 is 
more than 25 times faster at runtime than PostSharp 1.5!</b> Most importantly, the 
overhead of the aspect is now only <i>a small fraction</i> of the cost of the effect 
itself. So it now makes perfectly sense to use an aspect for lightweight 
instrumentation.</p>
<p>How does PostSharp 2.0 achieves this performance gain? In short, by being 
smarter about the code it generates. PostSharp 1.5 did not look into the code of 
your aspects, it had to generate code for any offered feature, even if your 
aspect did not use them. Therefore, PostSharp 1.5 generated a lot of useless 
instructions. This is clear if we looked at the output assembly using Reflector:</p>
<p align="center">
<img src="/assets/2009-09-24-introducing_postsharp_2_0_2_amazing_runtime_perfor/postsharp-1.5.gif" alt="Code generated by PostSharp 1.5" /></p>
<p>As you can see, there are instructions to pass the parameters of the method 
to the aspect, even if the aspect never uses them. Handlers <i>OnSuccess</i>, <i>
OnException</i> and <i>OnExit</i> are invoked, even if the aspect does not 
implement them. That&#39;s bad overhead: it does not translate into anything 
useful.</p>
<p>PostSharp 2.0 is way smarter: it analyzes the code of your aspect, figures
out which feature you actually use, and generate instructions only for them. Watch the difference:</p>
<p align="center">
<img src="/assets/2009-09-24-introducing_postsharp_2_0_2_amazing_runtime_perfor/postsharp-2.0.gif" alt="Code generated by PostSharp 2.0" /></p>


<p>No wonder it&#39;s faster. Since the aspect does not even use the <i>eventArgs</i> 
object, why should we pass it? PostSharp 2.0 is smarter than you could think: it 
also looks at which member of <i>MethodExecutionEventArgs</i> you are using. So 
if you read the <i>Instance</i> property and not the <i>Arguments</i> property, 
you will get <i>Instance</i>, not <i>Arguments</i>.</p>
<p>Sure, there is a catch in this benchmark: I have intentionally chosen an 
example where the improvement is dramatic. But, from today, you know that you can 
achieve amazing performance with <i>OnMethodBoundaryAspect</i>, and that it&#39;s up 
to you to design an aspect that is really lightweight at runtime. The learning 
curve of PostSharp has always been pay-as-you-consume. Now runtime performance 
is also pay-as-you-consume.</p>
<p>What with other aspects? Take <i>
OnMethodInvocationAspect</i>. It has been reimplemented from scratch, is now 
named <i>MethodInterceptionAspect</i>, and is 
"just" 77% faster in PostSharp 2.0 than in PostSharp 1.5.</p>
<p>PostSharp 2.0 delivers better runtime performance by playing on 3 factors:</p>
<ul>
<li>Adaptive Code Generation, as demonstrated above (major benefits in <i>
OnMethodBoundaryAspect</i>, minor benefits elsewhere).</li>
<li>Use of generic tuples instead of untyped arrays to store arguments (no 
boxing-unboxing, no casting).</li>
<li>Use of binding classes instead of delegates.</li>
<li>Aggressively optimized design (we <i>do</i> consider a virtual call or a 
boxing/unboxing cycle as an expensive operation).</li>
<li>Cross-aspect optimizations, delivering great benefits when many aspects 
are applied to the same method (artifacts used by an aspect can be reused by 
next aspects in chain).</li>
</ul>
<p>Now a last piece of code. What if a 3 ns overhead is still too much for your 
case? Look at the following piece of code, it has <i>zero</i> overhead.</p>
<pre>[Serializable]
public sealed class MethodInvocationCounter3Attribute : MethodLevelAspect
{
    [NonSerialized]
    private readonly static PerformanceCounter performanceCounter;

    static MethodInvocationCounter3Attribute()
    {
        if ( !PostSharpEnvironment.IsPostSharpRunning )
        {
            performanceCounter = new PerformanceCounter("Custom", "NumberOfItems64", false);
        }
    }

    [OnMethodEntryHandler, SelfSelector]
    public static void OnEntry(MethodExecutionArgs eventArgs)
    {
        performanceCounter.Increment();
    }
}</pre>
<p>The <i>OnEntry</i> handler is a static method. So, when applied on a target 
method, it gives the following:</p>
<p>
<img src="/assets/2009-09-24-introducing_postsharp_2_0_2_amazing_runtime_perfor/postsharp-2.0-static.gif" alt="Code generated by PostSharp 2.0 - Static Method" width="362" height="67" /></p>
<p>Since the OnEntry handler is inlined by the JIT compiler, this method is 
strictly equivalent to invoking <i>performanceCounter.Increment</i> manually 
from the instrumented method. Sure, your possibilities are very limited when you 
use a static method (you can&#39;t access instance fields of the aspect instance, so 
the counter name has to be the same for all methods using this aspect). But the 
promise holds: you use nothing, you pay nothing. Here, the aspect is free of any 
overhead.</p>
<p>Happy PostSharping!</p>
<p>-gael</p>

<p>PS. Kicking ass? </p>

